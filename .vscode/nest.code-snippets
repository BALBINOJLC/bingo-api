{
    // NEST

    // Modules Standar

    "Nest Create Schema": {
        "prefix": "Nest_create_schema",
        "body": [
            "import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';",
            "import { Document, Types } from 'mongoose';",

            "",
            "export const $1SchemaName = '$1';",
            "",
            "@Schema({ collection: '$2', timestamps: true })",
            "",

            "export class $1 {",
            "",
            "    @Prop({",
            "        type: String,",
            "        required: true,",
            "    })",
            "    field1: string;",
            "",
            "    @Prop({",
            "      type: String,",
            "      required: true,",
            "    })",
            "    field2: string;",
            "",
            "    @Prop({ type: Boolean, default: false })",
            "    isDeleted: boolean;",
            "",
            "    @Prop({ type: Date })",
            "    deletedAt: Date;",
            "",
            "}",

            "",
            "export type $1Document = $1 & Document;",
            "",
            "export const $1Schema = SchemaFactory.createForClass($1);"
        ]
    },

    "Nest Create DTO": {
        "prefix": "Nest_create_dto",
        "body": [
            "import { ApiProperty, PartialType } from '@nestjs/swagger';",
            "import { ResponseList } from '@utils';",
            "import { IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';",
            "import { $1Document } from '../schemas';",
            "",
            "export class Create$1Dto {",
            "    @IsString()",
            "    @IsNotEmpty()",
            "    @ApiProperty({",
            "        description: 'The $1 item',",
            "        example: 'What is the meaning of life?',",
            "    })",
            "    item1: string;",
            "",
            "     @IsMongoId()",
            "     @IsOptional()",
            "     @ApiProperty({",
            "         description: 'The $1 id',",
            "         example: '5e8f8f8f8f8f8f8f8f8f8f8',",
            "     })",
            "     item2: string;",
            " }",

            "export class Update$1Dto extends PartialType(Create$1Dto) {}",
            "",
            "export class Filter$1Dto {",
            "    @IsOptional()",
            "    @IsMongoId()",
            "    @ApiProperty({",
            "        description: 'The $1 id',",
            "        example: '5e8f8f8f8f8f8f8f8f8f8f8',",
            "    })",
            "    readonly _id?: string;",
            "}",

            "export class Resp$1List extends ResponseList {",
            "    data: $1Document[];",
            "}"
        ]
    },

    "Nest Create Controller": {
        "prefix": "Nest_create_controller",
        "body": [
            "import { Body, Controller, Delete, Get, Param, Post, Put, Query, Req, Res, UseGuards } from '@nestjs/common';",
            "import { ApiBearerAuth, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';",
            "import { JwtAuthGuard, ParamsDto, RequestWithUser } from '@utils';",
            "import { Create$1Dto, Update$1Dto, Filter$1Dto } from '../dtos';",
            "import { $1Service } from '../services';",
            "import { Response } from 'express';",
            "import { RequestHandlerUtil } from '@utils';",
            "",
            "@ApiTags('$1')",
            "@Controller({",
            "    path: '$2',",
            "    version: '1',",
            "})",
            "export class $1Controller {",
            "    constructor(private readonly _$2Service: $1Service) {}",
            "",
            "    @Get(':limit/:offset/:sort/:fields?')",
            "    @ApiParam({",
            "        name: 'fields',",
            "        required: true,",
            "        description: 'If not send fields need send white space',",
            "    })",
            "    @ApiOperation({})",
            "    @ApiBearerAuth()",
            "    @UseGuards(JwtAuthGuard)",
            "    async findAll(",
            "        @Param() params: ParamsDto,",
            "        @Query() query: Filter$1Dto,",
            "        @Req() req: RequestWithUser,",
            "        @Res() res: Response",
            "    ): Promise<Response | void> {",
            "        const { user } = req;",
            "        return RequestHandlerUtil.handleRequest(() => this._$2Service.findAll(query, params, user), res);",
            "    }",
            "",
            "    @Get(':fields?')",
            "    @ApiParam({",
            "        name: 'fields',",
            "        required: true,",
            "        description: 'If not send fields need send white space',",
            "    })",
            "    @ApiOperation({})",
            "    @ApiBearerAuth()",
            "    @UseGuards(JwtAuthGuard)",
            "    async findOne(",
            "        @Query() query: Filter$1Dto,",
            "        @Param('fields') fields: string,",
            "        @Req() req: RequestWithUser,",
            "        @Res() res: Response",
            "    ): Promise<Response | void> {",
            "        const { user } = req;",
            "        return RequestHandlerUtil.handleRequest(() => this._$2Service.findOne(query, fields, user), res);",
            "    }",
            "",
            "    @Post()",
            "    @ApiOperation({})",
            "    @ApiBearerAuth()",
            "    @UseGuards(JwtAuthGuard)",
            "    async create(",
            "        @Body() payload: Create$1Dto,",
            "        @Req() req: RequestWithUser,",
            "        @Res() res: Response",
            "    ): Promise<Response | void> {",
            "        const { user } = req;",
            "        return RequestHandlerUtil.handleRequest(() => this._$2Service.create(payload, user), res);",
            "    }",
            "",
            "    @Put()",
            "    @ApiOperation({})",
            "    @ApiBearerAuth()",
            "    @UseGuards(JwtAuthGuard)",
            "    async update(",
            "        @Body() body: Update$1Dto,",
            "        @Query() query: Filter$1Dto,",
            "        @Req() req: RequestWithUser,",
            "        @Res() res: Response",
            "    ): Promise<Response | void> {",
            "        const { user } = req;",
            "        return RequestHandlerUtil.handleRequest(() => this._$2Service.update(query, body, user), res);",
            "    }",
            "",
            "    @Delete(':id')",
            "    @ApiOperation({})",
            "    @ApiBearerAuth()",
            "    @UseGuards(JwtAuthGuard)",
            "    async delete(",
            "        @Param('id') id: string,",
            "        @Req() req: RequestWithUser,",
            "        @Res() res: Response",
            "    ): Promise<Response | void> {",
            "        const { user } = req;",
            "        return RequestHandlerUtil.handleRequest(() => this._$2Service.delete(id, user), res);",
            "    }",
            "}"
        ]
    },

    "Nest Create Interface": {
        "prefix": "Nest_create_interface",
        "body": [
            "import { $1Document } from '../schemas';",
            "",
            "export interface IResp$1Updated {",
            "    data: $1Document;",
            "    message: string;",
            "}"
        ]
    },

    "Nest Create Service": {
        "prefix": "Nest_create_service",
        "body": [
            "import { HttpException, HttpStatus, Injectable } from '@nestjs/common';",
            "import { InjectModel } from '@nestjs/mongoose';",
            "import { CustomError, ParamsDto } from '@utils';",
            "import { Model } from 'mongoose';",
            "import { Resp$1List, Create$1Dto, Filter$1Dto, Update$1Dto } from '../dtos';",
            "import { $1Document, $1SchemaName } from '../schemas';",
            "import { IResp$1Updated } from '../interfaces';",
            "",
            "@Injectable()",
            "export class $1Service {",
            "    constructor(",
            "        @InjectModel($1SchemaName)",
            "        private readonly model: Model<$1Document>",
            "    ) {}",
            "",
            "async create(input: Create$1Dto):Promise<$1Document> {",
            "      try {",
            "          const data = new this.model({",
            "              ...input,",
            "          });",
            "          const DB = await data.save();",
            "          return DB;",
            "      } catch (err) {",

            "          throw new CustomError({",
            "            message: '$2.ERRORS.CREATE',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "          });",
            "      }",
            "}",
            "",
            "  async findAll(filter: Filter$1Dto, params: ParamsDto): Promise<Resp$1List> {",
            "    const query = {",
            "        ...filter,",
            "        isDeleted: false,",
            "    };",
            "    const { fields, limit, offset, sort } = params;",
            "    const newSort = JSON.parse(sort);",
            "",
            "    try {",
            "        let perPage = limit;",
            "        const length = await this.model.find(query).countDocuments();",
            "        const data = await this.model",
            "            .find(query, fields)",
            "            .sort({ [newSort.field]: newSort.order })",
            "            .skip(offset)",
            "            .limit(limit)",
            "            .exec();",
            "",
            "        if (length === 0 || limit === 0) {",
            "            perPage = length;",
            "        }",
            "",
            "        return {",
            "            data,",
            "            page: offset,",
            "            per_page: perPage,",
            "            total_count: length,",
            "        };",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.FIND_ALL',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            "",
            "  async search(filter: Filter$1Dto, regExp: RegExp, params: ParamsDto): Promise<Resp$1List> {",
            "    const query = {",
            "        ...filter,",
            "        isDeleted: false,",
            "    };",
            "",
            "    const { sort, fields } = params;",
            "    const newSort = JSON.parse(sort);",
            "",
            "    try {",
            "        const length = await this.model",
            "            .find(query, fields)",
            "            .or([{ firstName: regExp }, { lastName: regExp }, { displayName: regExp }, { email: regExp }])",
            "            .countDocuments();",
            "",
            "        const data = await this.model",
            "            .find(query)",
            "            .or([{ firstName: regExp }, { lastName: regExp }, { displayName: regExp }, { email: regExp }])",
            "            .sort({ [newSort.field]: newSort.order })",
            "            .exec();",
            "",
            "        return {",
            "            data,",
            "            page: 0,",
            "            per_page: length,",
            "            total_count: length,",
            "        };",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.FIND',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            "",
            "  async findOne(filter: Filter$1Dto, fields?: string): Promise<$1Document> {",
            "    const query = {",
            "        ...filter,",
            "        isDeleted: false,",
            "    };",
            "",
            "    try {",
            "        const data = await this.model.findOne(query, fields).exec();",
            "        if (!data) {",
            "            throw new CustomError({",
            "                message: '$2.ERRORS.NOT_FOUND',",
            "                statusCode: HttpStatus.NOT_FOUND,",
            "                module: this.constructor.name,",
            "            });",
            "        }",
            "        return data;",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.FIND',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            "",
            "  async update(filter: Filter$1Dto, input: Update$1Dto): Promise<IResp$1Updated> {",
            "    const query = {",
            "        ...filter,",
            "        isDeleted: false,",
            "    };",
            "",
            "    try {",
            "        const data = await this.model.findOneAndUpdate(query, input, { new: true });",
            "        if (!data) {",
            "            throw new CustomError({",
            "                message: '$2.ERRORS.UPDATE.NOT_FOUND',",
            "                statusCode: HttpStatus.NOT_FOUND,",
            "                module: this.constructor.name,",
            "            });",
            "        }",
            "        return {",
            "            data,",
            "            message: '$2.SUCCESS.UPDATED',",
            "        };",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.UPDATE.BAD_REQUEST',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            "",
            "  async delete(id: string): Promise<{ message: string }> {",
            "    try {",
            "        const dataToDelete = await this.model.findById(id).exec();",
            "        if (!dataToDelete) {",
            "            throw new CustomError({",
            "                message: '$2.ERRORS.NOT_FOUND',",
            "                statusCode: HttpStatus.NOT_FOUND,",
            "                module: this.constructor.name,",
            "            });",
            "        }",
            "        const newData = {",
            "            uniqueField: `${dataToDelete.uniqueField}-IsDelete-${new Date().getTime()}`,",
            "            isDeleted: true,",
            "            deletedAt: new Date(),",
            "        };",
            "        await this.model.findByIdAndUpdate(id, newData, { new: true }).exec();",
            "        return {",
            "            message: '$2.SUCCESS.DELETED',",
            "        };",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.DELETE',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            "",
            "  async have$1(filter: Filter$1Dto): Promise<$1Document> {",
            "    const query = {",
            "        ...filter,",
            "        isDeleted: false,",
            "    };",
            "",
            "    try {",
            "        const data = await this.model.findOne(query).exec();",
            "        if (!data) {",
            "            return null;",
            "        }",
            "        return data;",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.FIND',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}"
        ]
    },

    "Nest Create Module": {
        "prefix": "Nest_create_module",
        "body": [
            "import { Module } from '@nestjs/common';",
            "import { $1Service } from './services';",
            "import { $1Controller } from './controllers';",
            "import { MongooseModule } from '@nestjs/mongoose';",
            "import { $1Schema, $1SchemaName } from './schemas';",
            "",
            "@Module({",
            "  imports: [",
            "    MongooseModule.forFeature([{ name: $1SchemaName, schema: $1Schema }]),",
            "  ],",
            "  providers: [$1Service],",
            "  controllers: [$1Controller],",
            "  exports: [$1Service]",
            "})",
            "export class $1Module {}"
        ]
    },

    "Nest Index Export Module": {
        "prefix": "Nest_index_export_module",
        "body": [
            "export * from './$1.module';",
            "export * from './controllers';",
            "export * from './services';",
            "export * from './schemas';",
            "export * from './dtos';"
        ]
    },

    "Console.dir with depth:null": {
        "prefix": "log_dir",
        "body": ["console.dir(${1:object}, { depth: null });"],
        "description": "Log nested object"
    },

    // Modules Individuals

    "Nest Create Service ADD": {
        "prefix": "Nest_create_service_add",
        "body": [
            "",
            "async create(input: Create$1Dto): Promise<$1Document> {",
            "    try {",
            "        const data = new this.model({",
            "            ...input,",
            "        });",
            "        const DB = await data.save();",
            "        return DB;",
            "    } catch (err) {",
            "        throw new CustomError({",
            "            message: '$2.ERRORS.CREATE',",
            "            statusCode: HttpStatus.BAD_REQUEST,",
            "            module: this.constructor.name,",
            "            innerError: err,",
            "        });",
            "    }",
            "}",

            ""
        ]
    }
}
